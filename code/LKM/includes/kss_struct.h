#ifndef KSSSTRUCT_H
#define KSSSTRUCT_H

#include "instr-map.h"


/**
 * stack_item - This data structure represents a set of information maintained to validate a single
 * Return address in the user stack.It represents a single element within the
 * New Stack Kernel.The Stack Kernel is implemented through a connected list by exploiting the elements
 * present in a memory buffer.In this way, it is possible to exploit the space location and remove a
 * 'central' element in the list with a cost equal to or (1).
 *
 * @return_address: return address that must be present at @addr_stack_user
 * @addr_stack_user: address in the user stack in which the return address @retururn_address must be found
 * @next: Next element in the connected list
 * @prev: previous element in the connected list
 */
typedef struct stack_item {
    unsigned long return_address;
    unsigned long addr_stack_user;
    struct stack_item *next;
    struct stack_item *prev;
} stack_item;

/**
 * Free_item - This data structure represents an element of the connected list containing the location
 * of the corresponding free element in the new Kernel Stack which can be used to maintain some
 * New validation information by inserting it in the new Kernel level stack.
 *
 * @next: Next element in the connected list
 */
typedef struct free_item {
    struct free_item *next;
} free_item;

/**
* Security_Medata - contains safety metadata for a specific thread that uses architecture.
 *
 * @magic_number: Magic Number to control the integrity of the data structure
 * @base: pointer at the base of the new Kernel Stack (the head of the list doubly connected)
 * @Top: Puntor at the current top of the new Kernel Stack (the tail of the list doubly connected)
 * @first_free_item: pointer at the head of the list containing the elements of free stacks
 * @free_items: memory buffer containing the correspondences of the free stack elements
 * @kernel_stack: Memory buffer containing the stack elements
 * @instrum_map: Puntor at the Map of Instrumentation for the Thread
 * @lsi: Puntor to monitoring information
 * @buffer_log: Buffer pointer containing the events generated by the thread to be shown on the log file
 * @Offset_log: Location in the log buffer from which the next event must be written
 * @stack_user_copy: It is a flag indicating if the user stack has been copied to report it on a log file
 * @stack_frame_size_sum: sum of the size of the frames frame of the active functions
 * @num_stack_frame_pend: number of stacks frame of the active functions
 * @array_stack_Pointers: Array containing the final addresses of the Frame Stack of the active functions
 * @copy_stack_user: Memory buffer in which the portion of User Stack of Al Massimo n Byte will be copied
 */
typedef struct security_metadata {
    unsigned long magic_number;
    stack_item * base;
    stack_item * top;
    free_item *first_free_item;
    free_item *free_items;
    stack_item *kernel_stack;
    struct ioctl_data * instrum_map;

#ifdef LOG_SYSTEM
    log_system_info *lsi;
    unsigned char *buffer_log;
    int offset_log;
    bool stack_user_copy;
#endif
#ifdef MIX_ADDRESS
    unsigned long stack_frame_size_sum;
    int num_stack_frame_pend;
    unsigned long *array_stack_pointers;
    unsigned char *copy_stack_user;
#endif
} security_metadata;

/* Get the pointer to the safety metadata stored on the original kernel stack                             */
#define GET_SECURITY_METADATA(end_of_stack, sm) sm = (security_metadata *)end_of_stack[1];

// Functions
extern int check_integrity_security_metadata(unsigned long *end_of_stack);
extern int check_error_finish_task_switch_hook(unsigned long *end_of_stack);
extern int check_error_security_metadata(unsigned long *end_of_stack);
extern stack_item *get_free_item(unsigned long *end_of_stack);
extern void insert_free_item(stack_item *item, security_metadata *sm);
extern void del_item_stack(stack_item *item, security_metadata *sm);

#ifdef LOG_SYSTEM
extern int single_address_one_copy(stack_item* top_stack, unsigned long user_stack_address, unsigned long *return_address, security_metadata *sm, unsigned long regs_ip);
extern int block_address(stack_item* top_stack, unsigned long user_stack_address, unsigned long *return_address, security_metadata *sm, unsigned long regs_ip);
extern int single_address(stack_item* top_stack, unsigned long user_stack_address, unsigned long *return_address, security_metadata *sm, unsigned long regs_ip);
extern int iter_block_address(stack_item* top_stack, unsigned long user_stack_address, unsigned long *return_address, security_metadata *sm, unsigned long regs_ip);
extern int check_all_return_adress(stack_item* top_stack, unsigned long user_stack_address, unsigned long *return_address, security_metadata *sm, unsigned long regs_ip);


#else
extern int single_address_one_copy(stack_item* top_stack, unsigned long user_stack_address, unsigned long *return_address, security_metadata *sm);
extern int block_address(stack_item* top_stack, unsigned long user_stack_address, unsigned long *return_address, security_metadata *sm);
extern int single_address(stack_item* top_stack, unsigned long user_stack_address, unsigned long *return_address, security_metadata *sm);
extern int iter_block_address(stack_item* top_stack, unsigned long user_stack_address, unsigned long *return_address, security_metadata *sm);
extern int check_all_return_adress(stack_item* top_stack, unsigned long user_stack_address, unsigned long *return_address, security_metadata *sm);
#endif

//in utils.c
extern int check_0x06(unsigned long ret_instr_addr, security_metadata *sm);
extern int check_int_0xFF(unsigned long call_instr_addr, security_metadata *sm) ;

//in logging.c
extern int save_user_stack(unsigned long start_address, security_metadata *sm);
extern int init_buffer_log(security_metadata *sm);
extern int buffer_log_switch(security_metadata *sm);
extern int write_suc_event_to_log_buffer(unsigned long ret_addr_kernel, 
                unsigned long ret_addr_user, unsigned long ret_instr_addr, security_metadata *sm);
extern int write_ret_event_to_log_buffer(unsigned long ret_instr_addr, unsigned long return_address, 
                security_metadata *sm, bool is_ii);
extern int write_call_event_to_log_buffer(unsigned long target_func_addr, unsigned long return_address, security_metadata *sm);
extern int write_no_call_event_to_log_buffer(unsigned long ret_instr_addr, unsigned long return_address, security_metadata *sm);

#ifdef SINGLE_ADDRESS_TIMER
extern unsigned long average_time_one_byte ;
extern unsigned long total_time_one_byte ;
extern unsigned long counter_one_byte ;
#endif //SINGLE_ADDRESS_TIMER

#ifdef BLOCK_ADDRESS_TIMER
extern unsigned long average_time_block ;
extern unsigned long total_time_block;
extern unsigned long counter_block ;
#endif //BLOCK_ADDRESS_TIMER

#ifdef TIMER_COMPARE_RET_ADDR
extern unsigned long average_time_compare ;
extern unsigned long total_time_compare ;
extern unsigned long counter_compare ;
extern int guard ;
#endif


#endif