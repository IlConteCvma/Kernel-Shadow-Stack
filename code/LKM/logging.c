#include "includes/logging.h"
#include "includes/kss_struct.h"
#include "includes/utils.h"
#include <linux/slab.h>

/* Workqueue name */
const char *workqueue_name = "workqueue_kss";
/* Workqueue for the asynchronous writing of events and the portion of corrupt user stack on log files */
struct workqueue_struct *wq;

/**
 * Flush_buffer_log - It is performed by the Kernel Worker Daemon to bring events back to files
 * generated by the threads during the execution or the copy of the portion of the user stack in the
 * case in which a SUC type event has occurred for the first time.
 *
 * @data: pointer to the topics
 */
void flush_buffer_log(unsigned long data) {

    param_kworker *pk;
    struct file *filp;
    unsigned char *buffer_log;
    char filename[512] = {0};
    unsigned long *user_stack;

    
    /* Recovery the topics relating to the work that is processing */
    pk = container_of((void *)data, param_kworker, the_work);

    /* I check if you have to report a buffer of events or the copy of the corrupt user stack */

    if(pk->type) {

        /* Recovery the pointer to the portion of the user stack to be reportede */
        user_stack = pk->user_stack;

        /* CI obstruct the name of the log file */
        snprintf(filename, 512, user_stack_path_format, pk->program_name, pk->id_user, pk->tid);

        /* I open a i/o session on the log file */
        filp = init_log(filename);

        /* I report the contents of the buffer on file */
        kernel_write(filp, user_stack, pk->user_stack_size, 0);

        /* I close the I/O session */
        close_log(filp);

        kfree((void *)user_stack);
        
    } else {

        /* Recovery the log buffer containing the events to be reported */
        buffer_log = pk->buffer_log;

        /* I build the name of the log file */
        snprintf(filename, 512, log_path_format, pk->program_name, pk->id_user, pk->tid);

        /* I open a i/o session on the log file */
        filp = init_log(filename);

        /* I report the contents of the buffer on file */
        kernel_write(filp, buffer_log, strlen(buffer_log), 0);

        /* I close the I/O session */
        close_log(filp);

        /* Log buffer free */
        free_pages((unsigned long)buffer_log, ORDER);
    }
}

/**
 * Save_user_stack - recovers the portion of Stack and delegates his writing on files to the Kworker Daemon.
 *
 * @start_address: initial address (lower part of the stack) of the portion of corrupt user stack
 * @sm: Safety metadata pointer
 *
 * @return: returns the value 0 in case of success;Otherwise, it returns the value -1.
 */
int save_user_stack(unsigned long start_address, security_metadata *sm) {
    int ret;
    param_kworker *pk;
    unsigned long size_copy;
    unsigned long *buffer;
    size_t size;


    dprint_info_log("%s: [SAVE USER STACK] [%d] Range Stack User to copy [%px , %px]\n",
            MOD_NAME,
            current->pid,
            (void *)start_address,
            (current->mm)->start_stack);


    /* Calculation the size of the portion of the user stack to be copied containing the return addresses */
    size_copy = (current->mm)->start_stack - start_address + sizeof(unsigned long);

    /* The Kernel level Buffer will contain the portion of the user stack with the Indrizzi */
    buffer = (unsigned long *)kmalloc(size_copy, GFP_KERNEL);

    if((void *)buffer == NULL) {
        pr_err("%s: [ERROR SAVE USER STACK] [%d] It is not possible to allocate the buffer in which to copy the portion of the user stack\n",
               MOD_NAME,
               current->pid);
        return -1;
     }


    /*  copy the Kernel Buffer the portion of the user stack containing the return addresses to be validated*/
    ret = copy_from_user((void *)buffer, (void *)start_address, size_copy);

    if(ret) {
        pr_err("%s: [ERROR SAVE USER STACK] [%d] It is not possible to copy the content of the portion of the user stack\n",
               MOD_NAME,
               current->pid);
        return -1;
    }

    /*  prepare the topics to be moved on to the Kernel Worker Daemon */
    pk = (param_kworker *)kmalloc(sizeof(struct param_kworker), GFP_KERNEL);

    if(pk == NULL) {
        pr_err("%s: [ERROR SAVE USER STACK] [%d] Error in the allocation of the parameters to be moved to the Kworker Daemon\n",
                MOD_NAME,
                current->pid);
        return -1;
    }

    /* It is a buffer of events */
    pk->type = 1;
    pk->user_stack = (unsigned long *)buffer;
    pk->user_stack_size = size_copy;

    if(sm->lsi == NULL) {

        size = strlen("log_file_");

        pk->program_name = (char *)kmalloc(size + 1, GFP_KERNEL);

        strncpy((pk->program_name), "log_file_", size);

        (pk->program_name)[size] = '\0';

        pk->id_user = 0;
        
    } else {

        size = strlen((sm->lsi)->program_name);

        pk->program_name = (char *)kmalloc(size + 1, GFP_KERNEL);

        strncpy((pk->program_name), (sm->lsi)->program_name, size);

        (pk->program_name)[size] = '\0';

        pk->id_user = (sm->lsi)->id_user;

    }

    pk->tid = current->pid;

    /* I check a new work that must be performed by the Worker Thread*/
    __INIT_WORK(&(pk->the_work),(void*)flush_buffer_log,(unsigned long)(&(pk->the_work)));

    queue_work(wq, &(pk->the_work));

    return 0;
}

/**
 * Init_buffer_log - Alloca a new log buffer for the current thread.
 *
 * @sm: Safety metadata pointer
 *
 * @return: returns the value 0 in case of success;Otherwise, it returns the value -1.
 */
int init_buffer_log(security_metadata *sm) {

    /* Alloco the new log buffer */
    sm->buffer_log = (unsigned  char *)__get_free_pages(GFP_KERNEL, ORDER);

    if(!(sm->buffer_log)) {
        pr_err("%s: [ERROR INIT BUFFER LOG] [%d] It is not possible to allocate the memory for the log buffer\n", MOD_NAME, current->pid);
        return -1;
    }

    /* Initially the log buffer is empty */
    sm->offset_log = 0;

    return 0;
}

/**
 * Buffer_log_Switch - performs a change of log buffer when there is no enough space for
 * Write new events.Log's current buffer is sent to a Daemon Kworker to write the
 * its content within the log file associated with the current thread.
 *
 * @sm: Safety metadata pointer
 *
 * @return: returns the value 0 in case of success;Otherwise, it returns the value -1.
 */
int buffer_log_switch(security_metadata *sm) {

    unsigned char *old_buffer_log;
    param_kworker *pk;
    size_t size;
    int ret;


    /* Recupero il riferimento al buffer di LOG corrente da affidare al Kernel Worker Daemon */
    old_buffer_log = sm->buffer_log;

    /* Alloco un nuovo buffer di memoria per la scrittura dell'evento */
    ret = init_buffer_log(sm);

    if(ret == -1) {
        pr_err("%s: [ERRORE BUFFER LOG SWITCH] [%d] Errore nell'alloczione del buffer di memoria\n", MOD_NAME, current->pid);
        return -1;
    }

    /* Preparo gli argomenti da passare al Kernel Worker Daemon */
    pk = (param_kworker *)kmalloc(sizeof(struct param_kworker), GFP_KERNEL);

    if(pk == NULL) {
        pr_err("%s: [ERRORE BUFFER LOG SWITCH] [%d] Errore nel cambio del buffer di LOG (2)\n",
                MOD_NAME,
                current->pid);
        return -1;
    }

    /* E' un buffer di eventi */
    pk->type = 0;
    pk->user_stack = NULL;
    pk->buffer_log = old_buffer_log;


    if(sm->lsi == NULL) {

        size = strlen("log_file_");

        pk->program_name = (char *)kmalloc(size + 1, GFP_KERNEL);

        strncpy((pk->program_name), "log_file_", size);

        (pk->program_name)[size] = '\0';

        pk->id_user = 0;
        
    } else {

        size = strlen((sm->lsi)->program_name);

        pk->program_name = (char *)kmalloc(size + 1, GFP_KERNEL);

        strncpy((pk->program_name), (sm->lsi)->program_name, size);

        (pk->program_name)[size] = '\0';

        pk->id_user = (sm->lsi)->id_user;

    }

    pk->tid = current->pid;

    /* Accodo un nuovo work che dovrà essere eseguito dal worker thread */
    __INIT_WORK(&(pk->the_work),(void*)flush_buffer_log,(unsigned long)(&(pk->the_work)));

    queue_work(wq, &(pk->the_work));

    return 0;
}

/**
* Write_suc_event_to_log_buffer - writes a new SUC event in the log buffer.
 *
 * @ret_addr_kernel: correct return address on the Kernel Stack
 * @ret_addr_user: corrupt return address on the user stack
 * @ret_instr_addr: address of the RET instruction on which I observed the anomalous modification of the return address
 * @sm: Safety metadata pointer
 *
 * @return: returns the value -1 in case of error;Otherwise, it returns the value 0.
 */
int write_suc_event_to_log_buffer(unsigned long ret_addr_kernel, unsigned long ret_addr_user, unsigned long ret_instr_addr, security_metadata *sm) {

    int ret;
    size_t size;
    unsigned long base;
    char event_ret_suc[130 + 12] = {0};

    
    if(sm->lsi != NULL) {
        base = (sm->lsi)->memory_mapped_base;
    } else {
        base = 0;
    }

    /* Format the string to write inside the log buffer */
    snprintf(event_ret_suc,
             130 + 12,
             ret_suc_format,
             (void *)(ret_addr_kernel - base),
             (void *)(ret_addr_user - base),
             (void *)(ret_instr_addr - base));

    /* Recovery the actual number of bytes that has been written with formatting */
    size = strlen(event_ret_suc);

    /* I insert the string terminator */
    event_ret_suc[size] = '\0';

    if(sm->buffer_log == NULL) {

        /* It is the first event generated by the thread and the memory buffer must be allocated */
        ret = init_buffer_log(sm);

        /* I check if the buffer has been allocated correctly */
        if(ret == -1) {
            pr_err("%s: [ERROR SUC EVENT] [%d] Error in the allocation of the memory buffer\n", MOD_NAME, current->pid);
            return -1;
        }
    }

    /* I have to check if the memory available in the buffer is sufficient for writing the event */

    if((sm->offset_log + size) > BUFFER_DIM) {

        /* A new memory buffer must be allocated and delivering the current buffer to the Worker Thread */
        ret = buffer_log_switch(sm);

        /* I check if the change of buffer was carried out correctly */
        if(ret == -1) {
            pr_err("%s: [ERROR SUC EVENT] [%d] Error in log buffer switch\n", MOD_NAME, current->pid);
            return -1;
        }
    }

    /* At this point I have a large enough memory buffer to host the new event */
    strncpy((sm->buffer_log + sm->offset_log), event_ret_suc, size);

    /* I update the location for the next writing in the log buffer */
    sm->offset_log = sm->offset_log + size;

    /* I check if the portion of the user stack must be copied to write it in a log file */
    if(!(sm->stack_user_copy)) {
        save_user_stack((sm->top)->addr_stack_user, sm);
        sm->stack_user_copy = true;
    }


    dprint_info_log("%s: [Event registration] [%d] %s", MOD_NAME, current->pid, event_ret_suc);


    return 0;
}

/**
 * Writ_ret_event_to_log_buffer - writes in the log buffer a new Ret type event that can be tied to
 * a type II scenario or to a type ni scenario.
 *
 * @ret_instr_addr: address of the Ret education that is simulating
 * @return_address: return address on the top of the user stack
 * @sm: Safety metadata pointer
 * @is_II: Flag to distinguish a scenario II from a scenario ni
 *
 * @return: returns the value -1 in case of error;Otherwise, it returns the value 0.
 */
int write_ret_event_to_log_buffer(unsigned long ret_instr_addr, unsigned long return_address, security_metadata *sm, bool is_ii) {

    int ret;
    size_t size;
    unsigned long base;
    char event_ret[92 + 12] = {0};
    

    if(sm->lsi != NULL) {
        base = (sm->lsi)->memory_mapped_base;
    } else {
        base = 0;
    }

    if(is_ii) {
        snprintf(event_ret,
                 92 + 12,
                 ret_ii_format,
                 (void *)(ret_instr_addr - base),
                 (void *)(return_address - base));
    } else {
        snprintf(event_ret,
                 92 + 12,
                 ret_ni_format,
                 (void *)(ret_instr_addr - base),
                 (void *)(return_address - base));
    }

    size = strlen(event_ret);

    event_ret[size] = '\0';

    /* I have to check if the memory available in the buffer is sufficient for writing the event */

    if(sm->buffer_log == NULL) {

        /* It is the first event generated by the thread and the memory buffer must be allocated */
        ret = init_buffer_log(sm);

        /*I check if the buffer has been allocated correctly */
        if(ret == -1) {
            pr_err("%s: [ERROR RET EVENT] [%d] Error in the allocation of the memory buffer\n", MOD_NAME, current->pid);
            return -1;
        }
    }

    /* I check if there is enough space in the buffer for writing the event */

    if((sm->offset_log + size) > BUFFER_DIM) {

        /* A new memory buffer must be allocated and delivering the current buffer to the Worker Thread */
        ret = buffer_log_switch(sm);

        /* I check if the change of buffer was carried out correctly */
        if(ret == -1) {
            pr_err("%s: [ERRORE RET EVENT] [%d] Error in log buffer switch\n", MOD_NAME, current->pid);
            return -1;
        }
    }

    /* At this point I have a large enough memory buffer to host the new event */
    strncpy((sm->buffer_log + sm->offset_log), event_ret, size);

    /* I update the location for the next writing in the log buffer */
    sm->offset_log = sm->offset_log + size;


    dprint_info_log("%s: [Event registration] [%d] %s", MOD_NAME, current->pid, event_ret);


    return 0;
}

/**
 * write_call_event_to_log_buffer - Scrive nel LOG buffer un nuovo evento di tipo CALL.
 *
 * @target_func_addr: Indirizzo della funzione che viene invocata dalla CALL
 * @return_address  : Indirizzo di ritorno che verrà posizionato dalla CALL sulla cima dello stack utente
 * @sm:             : Puntatore ai metadati di sicurezza
 *
 * @return: Restituisce il valore -1 in caso di errore; altrimenti, restituisce il valore 0.
 */ 
int write_call_event_to_log_buffer(unsigned long target_func_addr, unsigned long return_address, security_metadata *sm) {

    int ret;
    size_t size;
    unsigned long base;
    char event_call[92 + 12] = {0};            


    /* Recovery the base from which the new program was loaded */
    if(sm->lsi != NULL) {
        base = (sm->lsi)->memory_mapped_base;
    } else {
        base = 0;
    }

    /* People the line that must be written within the log file respecting the format       */
    snprintf(event_call,
             92 + 12,
             call_format,
             (void *)(target_func_addr - base),
             (void *)(return_address - base));

    /* Recovery the actual size of the string to write in the log buffer */
    size = strlen(event_call);

    /* I include the string terminator */
    event_call[size] = '\0';

    /* I check if the log buffer has already been allocated */

    if(sm->buffer_log == NULL) {

        /* It is the first event generated by the thread and the memory buffer must be allocated */
        ret = init_buffer_log(sm);

        /* I check if the buffer has been allocated correctly */
        if(ret == -1) {
            pr_err("%s: [ERROR CALL EVENT] [%d] Error in the allocation of the memory buffer\n", MOD_NAME, current->pid);
            return -1;
        }
    }

    /* I have to check if the memory available in the buffer is sufficient for writing the new event */

    if((sm->offset_log + size) > BUFFER_DIM) {

        /* A new memory buffer must be allocated and delivering the current buffer to the Worker Thread */
        ret = buffer_log_switch(sm);

        /* I check if the change of buffer was carried out correctly */
        if(ret == -1) {
            pr_err("%s: [ERROR CALL EVENT] [%d] Error in log buffer switch\n", MOD_NAME, current->pid);
            return -1;
        }
    }

    /* At this point I have a large enough memory buffer to host the new event */
    strncpy((sm->buffer_log + sm->offset_log), event_call, size);

    /* I update the location for the next writing in the log buffer */
    sm->offset_log = sm->offset_log + size;


    dprint_info_log("%s: [Event registration] [%d] %s", MOD_NAME, current->pid, event_call);
    
    return 0;
}

/**
 * Write_no_call_event_to_log_buffer - writes a new no call type event in the log buffer.
 *
 * @ret_instr_addr: address of the Ret education that is simulating
 * @return_address: return address on the top of the user stack
 * @sm: Safety metadata pointer
 *
 * @return: returns the value -1 in case of error;Otherwise, it returns the value 0.
 */

int write_no_call_event_to_log_buffer(unsigned long ret_instr_addr, 
                            unsigned long return_address, security_metadata *sm) 
{

    int ret;
    size_t size;
    unsigned long base;
    char event_no_call[92 + 12] = {0};            


    if(sm->lsi != NULL) {
        base = (sm->lsi)->memory_mapped_base;
    } else {
        base = 0;
    }

    /* People the line that must be written within the log file respecting the format         */
    snprintf(event_no_call,
             92 + 12,
             no_call_format,
             (void *)(ret_instr_addr - base),
             (void *)(return_address));

    size = strlen(event_no_call);

    /* I include the string terminator                                                                */
    event_no_call[size] = '\0';

    if(sm->buffer_log == NULL) {

        /* It is the first event generated by the thread and the memory buffer must be allocated */
        ret = init_buffer_log(sm);

        /* I check if the buffer has been allocated correctly */
        if(ret == -1) {
            pr_err("%s: [ERRORE NOCALL EVENT] [%d] Error in the allocation of the memory buffer\n", MOD_NAME, current->pid);
            return -1;
        }
    }

    /* I have to check if the memory available in the buffer is sufficient for writing the event */

    if((sm->offset_log + size) > BUFFER_DIM) {

        /* A new memory buffer must be allocated and delivering the current buffer to the Worker Thread */
        ret = buffer_log_switch(sm);

        /* I check if the change of buffer was carried out correctly */
        if(ret == -1) {
            pr_err("%s: [ERROR NOCALL EVENT] [%d] Error in log buffer switch\n", MOD_NAME, current->pid);
            return -1;
        }
    }

    /* At this point I have a large enough memory buffer to host the new event*/
    strncpy((sm->buffer_log + sm->offset_log), event_no_call, size);

    /* I update the location for the next writing in the log buffer */
    sm->offset_log = sm->offset_log + size;


    dprint_info_log("%s: [Event registration] [%d] %s", MOD_NAME, current->pid, event_no_call);


    return 0;
}