#include "includes/workqueue.h"
#include "includes/utils.h"

/**
 * Flush_buffer_log - It is performed by the Kernel Worker Daemon to bring events back to files
 * generated by the threads during the execution or the copy of the portion of the user stack in the
 * case in which a SUC type event has occurred for the first time.
 *
 * @data: pointer to the topics
 */
void flush_buffer_log(unsigned long data) {

    param_kworker *pk;
    struct file *filp;
    unsigned char *buffer_log;
    char filename[512] = {0};
    unsigned long *user_stack;

    
    /* Recovery the topics relating to the work that is processing */
    pk = container_of((void *)data, param_kworker, the_work);

    /* I check if you have to report a buffer of events or the copy of the corrupt user stack */

    if(pk->type) {

        /* Recovery the pointer to the portion of the user stack to be reportede */
        user_stack = pk->user_stack;

        /* CI obstruct the name of the log file */
        snprintf(filename, 512, user_stack_path_format, pk->program_name, pk->id_user, pk->tid);

        /* I open a i/o session on the log file */
        filp = init_log(filename);

        /* I report the contents of the buffer on file */
        kernel_write(filp, user_stack, pk->user_stack_size, 0);

        /* I close the I/O session */
        close_log(filp);

        kfree((void *)user_stack);
        
    } else {

        /* Recovery the log buffer containing the events to be reported */
        buffer_log = pk->buffer_log;

        /* I build the name of the log file */
        snprintf(filename, 512, log_path_format, pk->program_name, pk->id_user, pk->tid);

        /* I open a i/o session on the log file */
        filp = init_log(filename);

        /* Riporto il contenuto del buffer su file */
        kernel_write(filp, buffer_log, strlen(buffer_log), 0);

        /* Chiudo la sessione di I/O */
        close_log(filp);

        /* Libero il buffer di LOG */
        free_pages((unsigned long)buffer_log, ORDER);
    }
}
